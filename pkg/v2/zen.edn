{ns zen

 namespace
 {:zen/tags #{schema}
  :zen/desc "Schema for namespace"
  :type map
  :key {:type symbol}
  :values {:type map}
  :keys {'ns      {:type symbol}
         'imports {:type set :every {:type symbol}}
         'require {:type map
                   :key {:type symbol}
                   :values {:type symbol :namepsaced true}}}}

 property
 {:zen/tags #{tag}
  :zen/desc "Global properties"}

 desc
 {:zen/tags #{property schema}
  :type string}

 file
 {:zen/tags #{property schema}
  :zen/desc "namespace filename"
  :type string}

 name {:zen/tags #{property schema}
       :type symbol}

 tag {:zen/tags #{tag}
      :zen/desc "tag for tag"}

 tags {:zen/tags #{property schema is-key}
       :zen/desc "list of zen tags"
       :type set
       :every {:type symbol :tags #{tag}}}

 is-key
 {:zen/tags #{tag schema}
  :desc "tag for schema keys"}

 is-type
 {:zen/tags #{tag}
  :zen/desc "tag for types"}

 schema
 {:zen/tags #{schema tag}
  :zen/desc "zen schema"
  :type map
  :keyname-schemas {:tags #{schema-fx}}
  :key-schema {:tags #{is-key} :key :type}}

 for
 {:zen/tags #{is-key schema}
  :zen/desc "binds rule to a set of symbols"
  :type set
  :every {:type symbol
          :tags #{is-type}}}

 type
 {:zen/tags #{is-key schema}
  :zen/desc "type key in schema"
  :type symbol
  :tags #{is-type}}

 confirms
 {:zen/tags #{is-key schema}
  :zen/desc "set of schemas to confirm"
  :type set
  :every {:type symbol :tags #{schema}}}

 case
 {:zen/tags #{is-type is-key schema}
  :type vector
  :every {:type map
          :require #{:when}
          :keys {:when {:confirms #{schema}}
                 :then {:confirms #{schema}}}}}

 const
 {:zen/tags #{is-key schema}
  :zen/desc "is value equal to constant?"
  :type map
  :keys {:value {:type any}}}

 match
 {:zen/tags #{is-key schema}
  :type any}

 fail
 {:zen/tags #{is-key schema}
  :type string}

 every
 {:zen/tags #{schema is-key}
  :zen/desc "bounds of numbers"
  :for #{vector set list}
  :confirms #{schema}}

 enum
 {:zen/tags #{is-key schema}
  :zen/desc "is value in enum?"
  :type vector
  :every {:type map
          :keys {:value {:type any}}}}

 effect {:zen/tags #{tag}}

 effects
 ;; TODO impl me
 {:zen/tags #{is-key schema}
  :zen/desc "reference key evaluation method"
  :type map
  :key-schema {:tags #{effect}}}

 regex
 {:zen/tags #{schema is-type is-key}
  :zen/desc "regexp type"
  :for #{string}}

 date
 {:zen/tags #{schema is-type}}

 datetime
 {:zen/tags #{schema is-type}}

 symbol
 {:zen/tags #{schema is-type}
  :zen/desc "validate symbol"}

 qsymbol
 ;; TODO impl me:
 {:zen/tags #{schema is-type}
  :zen/desc "validate quoted symbol"}

 keyword
 {:zen/tags #{schema is-type}
  ;; TODO implement me
  :keys {:ns {:type set
              :every {:type qsymbol}}}}

 string
 {:zen/tags #{schema is-type}}

 length
 {:zen/tags #{schema is-key}
  :for #{string}
  :zen/desc "lenght of string"}

 minLength
 {:zen/tags #{schema is-key}
  :for #{string}
  :type integer
  :min 0}

 maxLength
 {:zen/tags #{schema is-key}
  :for #{string}
  :type integer
  :min 0}

 boolean
 {:zen/tags #{schema is-type}}

 integer
 {:zen/tags #{schema is-type}
  :zen/desc "validate integer"}

 number
 {:zen/tags #{schema is-type}
  :zen/desc "validate integer"}

 bounds
 ;; TODO impl me
 {:zen/tags #{schema is-key}
  :zen/desc "bounds of numbers"
  :for #{integer number}
  :type vector
  :every {:type zen/integer}}

 min
 {:zen/tags #{schema is-key}
  :for #{integer number}
  :type number}

 max
 {:zen/tags #{schema is-key}
  :for #{integer number}
  :type number}

 precision
 {:zen/tags #{schema is-key}
  :for #{number}
  :type integer}

 scale
 {:zen/tags #{schema is-key}
  :for #{number}
  :type integer}

 list
 {:zen/tags #{schema is-type}}

 set
 {:zen/tags #{schema is-type}}

 superset-of
 {:zen/tags #{is-key schema}
  :for #{set}
  :type set}

 subset-of
 {:zen/tags #{is-key schema}
  :for #{set}
  :type set}

 vector
 {:zen/tags #{schema is-type}
  :zen/desc "validate vector"}

 schema-index
 {:zen/tags #{schema is-key}
  :for #{vector}
  :zen/desc "resolve schema name by vector index and ns"
  :type map
  :keys {:index {:type integer}
         :ns {:type string}}}

 nth
 {:zen/tags #{schema is-key}
  :zen/desc "apply schema to an element of vector"
  :for #{vector list}
  :type map
  :key   {:type integer}
  :value {:confirms #{schema}}}

 slicing
 {:zen/tags #{schema is-key}
  :zen/desc "define a slicing of a vector"
  :type map
  :require #{:slices}
  :keys {:rest {:zen/desc "elements that don't match any slice are validated with provided schema"
                :confirms #{schema}}
         :slices
         {:zen/desc "map of slice definitions"
          :type map
          :key {:type string}
          :values {:zen/desc "each slice definition contains :filter to match an element and :schema to validate it"
                   :type map
                   :require #{:filter :schema}
                   :keys {:filter {:type map
                                   :validation-type :open
                                   :require #{:engine}
                                   :keys {:zen {:confirms #{schema}}
                                          :engine {:type case
                                                   :case
                                                   [{:when {:enum [{:value :zen} {:value :zen-fx}]}}
                                                    {:when {:type zen/any}
                                                     :then {:fail "Unsupported engine"}}]}}}

                          :schema {:confirms #{schema}}}}}}}

 filter
 ;; TODO impl me
 {:zen/tags #{schema is-key}
  :zen/desc "bounds of numbers"
  :for #{vector set}}

 minItems
 {:zen/tags #{schema is-key}
  :for #{vector list set}
  :type integer
  :min 0}

 maxItems
 {:zen/tags #{schema is-key}
  :for #{vector list set}
  :type integer
  :min 0}

 vector-bounds
 ;; TODO impl me
 {:zen/tags #{schema is-key}
  :for #{vector set}
  :zen/desc "bounds of numbers"}

 vector-regex
 ;; TODO impl me
 {:zen/tags #{schema is-key}
  :for #{vector set}
  :zen/desc "bounds of numbers"}

 map
 {:zen/tags #{schema is-type}
  :type map}

 values
 {:zen/tags #{schema is-key}
  :zen/desc "validate values in map"
  :for #{map}
  :confirms #{schema}}

 validation-type
 {:zen/tags #{schema is-key}
  :zen/desc "closed-world or open-world validation mode"
  :type keyword
  :enum [{:value :open}
         {:value :closed}]}

 key-schema
 {:zen/tags #{is-key schema}
  :zen/desc "determine schema by key name"
  :for #{map}
  :type map
  :keys {:tags {:confirms #{tags}}
         :key {:type keyword}}}

 schema-key
 {:zen/tags #{is-key schema}
  :zen/desc "pick schema in runtime by provided key"
  :for #{map}
  :require #{:key}
  :type map
  :keys {:key  {:type keyword}
         ;; TODO impl me
         :ns {:type string}
         :resolve {:type map :values {:type symbol}}
         :tags {:confirms #{tags}}}}

 keys
 {:zen/tags #{schema is-key}
  :zen/desc "validate keys in map"
  :type map
  :for #{map}
  :values {:confirms #{schema}}}

 key
 {:zen/tags #{schema is-key}
  :zen/desc "validate key"
  :for #{map}
  :confirms #{schema}}

 keyname-schemas
 {:zen/tags #{schema is-key}
  :for #{map}
  :zen/desc "pick schema from keys of provided data"
  :type map
  :keys {:tags {:confirms #{tags}}}}

 require
 {:zen/tags #{schema is-key}
  :for #{map}
  :zen/desc "set of required keys"
  :type set
  :every {:type case
          :case [{:when {:type keyword}}
                 {:when {:type set
                         :zen/desc "matches one of a set'"
                         :every {:type keyword}}}]}}

 exclusive-keys
 {:zen/tags #{schema is-key}
  :for #{map}
  :type set
  :every {:type set
          :minItems 2
          :every {:type case
                  :case [{:when {:type keyword}}
                         {:when {:type set}
                          :then {:type set :every {:type keyword}}}]}}}

 any
 {:zen/tags #{is-type schema}
  :zen/desc "Any type"}

 schema-fx {:zen/tags #{tag}
            :zen/desc "Register schema effect"}

 apply      {:zen/tags #{is-type schema}
             :type map}

 fn         {:zen/tags #{schema tag}
             :type map
             :require #{:args :ret}
             :keys {:args {:confirms #{schema}}
                    :ret  {:confirms #{schema}}}}

 schema-errors
 {:zen/tags #{schema}
  :type vector
  :every {:type map
          :keys {:path {:type any}
                 :schema {:type any}
                 :message {:type string}
                 :resource {:type string}
                 :type {:type string}}}}

 schema-result
 {:zen/tags #{schema}
  :type map
  :keys {:errors {:confirms #{schema-errors}}}}}
