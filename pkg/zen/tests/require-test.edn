{ns zen.tests.require-test

 ;; TODO add deeply nested test with both or and all require

 basic-require
 {:zen/tags #{zen/schema}
  :type zen/map
  :require #{:foo :bar}
  :values {:type zen/string}}

 or-require
 {:zen/tags #{zen/schema}
  :type zen/map
  :require #{#{:foo :bar}}
  :values {:type zen/string}}

 nested-require
 {:zen/tags #{zen/schema}
  :type zen/map
  :keys {:attr {:type zen/map
                :require #{#{:foo :bar}}
                :values {:type zen/string}}}}

 a-require
 {:zen/tags #{zen/schema}
  :type zen/map
  :require #{:a}
  :values {:type zen/string}}

 b-require
 {:zen/tags #{zen/schema}
  :type zen/map
  :require #{:b}
  :values {:type zen/string}}

 ab-require
 {:zen/tags #{zen/schema}
  :type zen/map
  :confirms #{a-require b-require}}

 or-a-require
 {:zen/tags #{zen/schema}
  :type zen/map
  :confirms #{or-require a-require}}

 basic-require-test
 {:zen/tags #{zen.test/case}
  :title "require tests"
  :steps
  [{:desc "Empty data"
    :do {:type zen.test/validate :schema basic-require :data {}}
    :match {:errors
            [{:path [:bar]
              :type "require"
              :message ":bar is required"
              :schema [basic-require :require]}
             {:path [:foo]
              :message ":foo is required"
              :type "require"
              :schema [basic-require :require]}]}}

   {:desc "foo key missed"
    :do {:type zen.test/validate :schema basic-require :data {:bar 1}}
    :match
    {:errors [{:message "Expected type of 'string, got 'long"
               :type "string.type"
               :path [:bar]
               :schema [zen.tests.require-test/basic-require :values]}

              {:path [:foo]
               :type "require"
               :message ":foo is required"
               :schema [basic-require :require]}]}}

   {:desc "bar key missed"
    :do {:type zen.test/validate :schema basic-require :data {:foo 1}}
    :match
    {:errors [{:path [:bar]
               :message ":bar is required"
               :type "require"
               :schema [basic-require :require]}

              {:message "Expected type of 'string, got 'long"
               :type "string.type"
               :path [:foo]
               :schema [zen.tests.require-test/basic-require :values]}]}}

   {:desc "Valid data"
    :do {:type zen.test/validate
         :schema basic-require
         :data {:foo "foo" :bar "bar"}}
    :match {:errors zen.test/empty?}}

   {:desc "require or syntax - both foo and bar are present"
    :do {:type zen.test/validate
         :schema or-require
         :data {:foo "foo" :bar "bar"}}
    :match {:errors zen.test/empty?}}

   {:desc "require or syntax - foo is present"
    :do {:type zen.test/validate
         :schema or-require
         :data {:foo "foo"}}
    :match {:errors zen.test/empty?}}

   {:desc "require or syntax - bar is present"
    :do {:type zen.test/validate
         :schema or-require
         :data {:bar "bar"}}
    :match {:errors zen.test/empty?}}

   {:desc "require or syntax - no foo no bar"
    :do {:type zen.test/validate
         :schema or-require
         :data {:some "ups"}}
    :match {:errors
            [{:type "map.require"
              :message "one of keys #{:bar :foo} is required"
              :schema [or-require :require]
              :path zen.test/empty?}]}}

   {:desc "require either foo or bar and a - no foo no bar"
    :do {:type zen.test/validate
         :schema or-a-require
         :data {:a "value"}}
    :match {:errors
            [{:type "map.require"
              :message "one of keys #{:bar :foo} is required"
              :schema [or-a-require :confirms or-require :require]
              :path zen.test/empty?}]}}

   {:desc "require either foo or bar and a - all keys present"
    :do {:type zen.test/validate
         :schema or-a-require
         :data {:a "value"
                :bar "another-value"}}
    :match {:errors zen.test/empty?}}

   {:desc "nested require on empty data"
    :do {:type zen.test/validate
         :schema nested-require
         :data {}}
    :match {:errors zen.test/empty?}}

   {:desc "nested require when no keys present"
    :do {:type zen.test/validate
         :schema nested-require
         :data {:attr {:some ""}}}
    :match {:errors
            [{:type "map.require"
              :schema [nested-require :attr :require]
              :message "one of keys #{:bar :foo} is required"
              :path [:attr]}]}}

   {:desc "nested require when foo is present"
    :do {:type zen.test/validate
         :schema nested-require
         :data {:attr {:foo "my-value"}}}
    :match {:errors zen.test/empty?}}

   {:desc "nested require when bar is present"
    :do {:type zen.test/validate
         :schema nested-require
         :data {:attr {:bar "my-value"}}}
    :match {:errors zen.test/empty?}}

   {:desc "two schemas w confirms fail on empty data"
    :do {:type zen.test/validate
         :schema ab-require
         :data {}}
    :match {:errors
            [{:type "require"
              :message ":a is required"
              :path [:a]
              :schema [zen.tests.require-test/ab-require :confirms a-require :require]}
             {:type "require"
              :message ":b is required"
              :path [:b]
              :schema [zen.tests.require-test/ab-require :confirms b-require :require]}]}}

   {:desc "two schemas w confirms fail when b is not present"
    :do {:type zen.test/validate
         :schema ab-require
         :data {:a "a"}}
    :match {:errors
            [{:type "require"
              :message ":b is required"
              :path [:b]
              :schema [zen.tests.require-test/ab-require :confirms b-require :require]}]}}

   {:desc "two schemas w confirms when a, b are present"
    :do {:type zen.test/validate
         :schema ab-require
         :data {:a "a"
                :b "b"}}
    :match {:errors zen.test/empty?}}]}

 schema-a-recursive
 {:zen/tags #{zen/schema}
  :type zen/map
  :keys {:a {:type zen/string}}
  :confirms #{schema-b-recursive}}

 schema-b-recursive
 {:zen/tags #{zen/schema}
  :type zen/map
  :keys {:b {:type zen/string}}
  :confirms #{schema-a-recursive}}

 recursive-confirms-test
 {:zen/tags #{zen.test/case}
  :title "recursive confirms resolve correctly"
  :steps
  [{:desc "invalid data given"
    :do {:type zen.test/validate
         :schema schema-b-recursive
         :data {:c "value"}}
    :match
    {:errors
     [{:path [:c], :type "unknown-key", :message "unknown key :c"}]}}

   {:desc "valid data given"
    :do {:type zen.test/validate
         :schema schema-b-recursive
         :data {:a "value"
                :b "value"}}
    :match
    {:errors zen.test/empty?}}]}

 schema-c
 {:zen/tags #{zen/schema}
  :type zen/map
  :keys {:c {:type zen/string}}}

 schema-a
 {:zen/tags #{zen/schema}
  :type zen/map
  :keys {:a {:type zen/string}}
  :confirms #{schema-b schema-c}}

 schema-not-found-confirms-test
 {:zen/tags #{zen.test/case}
  :only-for #{:v2}
  :title "if schema is not found confirms returns an error"
  :steps
  [{:desc "invalid data given"
    :do {:type zen.test/validate
         :schema schema-a
         :data {:a "value"
                :c :wrong-value}}
    :match
    {:errors
     ;;schema-c is validated even if schema-b is not found
     [{:message "Expected type of 'string, got 'keyword"
       :path [:c]
       :type "string.type"
       :schema
       [zen.tests.require-test/schema-a
        :confirms
        zen.tests.require-test/schema-c
        :c
        :type]}

     ;; error from schema validation
      {:message
       "Expected symbol 'zen.tests.require-test/schema-b tagged with '#{zen/schema}, but only #{}"
       :type "symbol"
       :path [:confirms 1]
       :schema [zen/schema :confirms :every 1 :tags]}

      ;; error from data validation
      {:message "Could not resolve schema 'zen.tests.require-test/schema-b"
       :type "map.confirms"
       :path []
       :schema [zen.tests.require-test/schema-a :confirms]}]}}]}}
